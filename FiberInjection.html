
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fiber-based Injection</title>
  <style>
    /* General Reset */
    body, h1, h2, h3, p, ul {
      margin: 0;
      padding: 0;
      font-family: 'Arial', sans-serif;
      box-sizing: border-box;
    }

    body {
      line-height: 1.6;
      font-size: 16px;
      background-color: #f9f9f9;
      color: #333;
    }

    header {
      background: #2d2d2d;
      color: white;
      text-align: center;
      padding: 20px 0;
    }

    header h1 {
      font-size: 2.5rem;
    }

    header p {
      font-size: 1rem;
      margin-top: 10px;
      color: #bbb;
    }

    nav {
      background: #333;
      padding: 10px;
    }

    nav a {
      color: white;
      text-decoration: none;
      margin: 0 15px;
      font-size: 1rem;
    }

    nav a:hover {
      text-decoration: underline;
    }

    .container {
      max-width: 800px;
      margin: 20px auto;
      padding: 0 20px;
    }

    section {
      margin-bottom: 40px;
    }

    section h2 {
      font-size: 1.8rem;
      margin-bottom: 10px;
      color: #444;
    }

    section p {
      font-size: 1rem;
      margin-bottom: 10px;
      line-height: 1.8;
    }

    footer {
      background: #2d2d2d;
      color: white;
      text-align: center;
      padding: 10px 0;
      font-size: 0.9rem;
    }

    footer a {
      color: #58a6ff;
      text-decoration: none;
    }

    footer a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <header>
    <h1>Fiber-based Injection</h1>

  </header>

  <nav>
    <a href="#introduction">Introduction</a>
    <a href="#content">Content</a>
    <a href="#closing">Closing</a>
  </nav>

  <div class="container">
    <section id="introduction">
      <h2>Introduction</h2>
      For awhile now people have been relying on CreateThreadEx and other system calls that have been, for a long time, hooked into Defender and other EDR solutions. The common way to avoid this is using something called NT api calls which reside in NTDLL. These calls are important because they directly make the system call to the SSDT in the kernel. This is the "barrier" or in official terms a system call that seperates User mode and kernel mode. I will go more into detail on kernel mode in a future zine but as of now lets stick with user mode. These calls are made by the OS when making high level api calls like CreateFile() or CreateRemoteThread() Using these calls helps avoid detection but doesnt promise anything, but paired with more techniques this is ideal for writing undetected software. In this zine I will go into detail about a API called CreateFiber() and ConvertThreadToFiber() which allow for a new type of injection method.
    </section>

    <section id="content">
      <h2>Why Fibers?</h2>
Fibers are a User mode only feature of windows OS that have been around forever. Reading through windows internals(2016) I noticed something about fibers that was unique. Fibers are unique in that they have there own stack, operate only in user mode(ring 3), and control flow of execution like threads but are never seen by the scheduler. As I am obsessive over these sorts of things I crafted a POC of how fibers can be seen being used by APT in the wild and providing possible mitigations.

    </section>

    <section id="closing">
      <h2>Getting to work:</h2>
     As I got to work on the POC, I had just finished my debugger i wrote which also uses these same technique and goes deep into windows architecture and registers. The injector is the first of its kind using not 1 but 2 seperate fibers injected into a remote thread. My orginal idea was just injecting a then converting it to a fiber, But i decided to do 2 seperate fibers for the builder and loader to show the capability that fibers. I first created a process in windows and got a handle using OpenProcess(). Once the handle was recieved (which I set globally to use in the fibers). below is a example of how I did i.
    
        hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ | PROCESS_ALL_ACCESS, FALSE, pi.dwProcessId);
        if (hProcess) {
            LPVOID fiberMain = ConvertThreadToFiber(NULL); //convert the thread to a fiber
            LPVOID debugFiber = CreateFiber(0, debug, argv[1]); // setting up fiber

            printf("about to run the shellcode...\n"); // prep done 


            SwitchToFiber(debugFiber);

            //Hidden proc + obfuscated shellcode = full control

            DeleteFiber(debugFiber); 


        } else {
            printf("Failed to open process\n");
        }
        
        This snippet creates a fiber inside of the created process and then proceeds with its action.
    </section>
  </div>

  <footer>
          <p>Thank you for engaging with my zine on Fiber-based Injection. I hope this resource has provided valuable insights. Keep up with modern security by reading my zines..</p>
    <p>&copy; 2025 Sleepy All Rights Reserved. | <a href="https://github.com/sleepyG8">GitHub</a></p>
  </footer>
</body>
</html>